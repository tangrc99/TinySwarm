// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: WorkerRpcInterface.proto

#include "WorkerRpcInterface.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR UserServiceDescriptor::UserServiceDescriptor(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.service_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.alias_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct UserServiceDescriptorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UserServiceDescriptorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~UserServiceDescriptorDefaultTypeInternal() {}
  union {
    UserServiceDescriptor _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UserServiceDescriptorDefaultTypeInternal _UserServiceDescriptor_default_instance_;
PROTOBUF_CONSTEXPR ForkInput::ForkInput(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.exe_params_)*/{}
  , /*decltype(_impl_.docker_params_)*/{}
  , /*decltype(_impl_.service_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.owner_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.alias_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.restart_)*/0
  , /*decltype(_impl_.port_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ForkInputDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ForkInputDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ForkInputDefaultTypeInternal() {}
  union {
    ForkInput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ForkInputDefaultTypeInternal _ForkInput_default_instance_;
PROTOBUF_CONSTEXPR ForkEcho::ForkEcho(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.error_text_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sd_)*/nullptr
  , /*decltype(_impl_.fail_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ForkEchoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ForkEchoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ForkEchoDefaultTypeInternal() {}
  union {
    ForkEcho _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ForkEchoDefaultTypeInternal _ForkEcho_default_instance_;
PROTOBUF_CONSTEXPR ShutdownInput::ShutdownInput(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.user_info_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sd_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ShutdownInputDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShutdownInputDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShutdownInputDefaultTypeInternal() {}
  union {
    ShutdownInput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShutdownInputDefaultTypeInternal _ShutdownInput_default_instance_;
PROTOBUF_CONSTEXPR Echo::Echo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.error_text_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.fail_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EchoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EchoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EchoDefaultTypeInternal() {}
  union {
    Echo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EchoDefaultTypeInternal _Echo_default_instance_;
PROTOBUF_CONSTEXPR CheckInput::CheckInput(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.user_info_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.line_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CheckInputDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CheckInputDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CheckInputDefaultTypeInternal() {}
  union {
    CheckInput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CheckInputDefaultTypeInternal _CheckInput_default_instance_;
PROTOBUF_CONSTEXPR DownService::DownService(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.error_text_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.alias_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.out_file_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.exit_num_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DownServiceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DownServiceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DownServiceDefaultTypeInternal() {}
  union {
    DownService _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DownServiceDefaultTypeInternal _DownService_default_instance_;
PROTOBUF_CONSTEXPR DownServices::DownServices(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.service_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DownServicesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DownServicesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DownServicesDefaultTypeInternal() {}
  union {
    DownServices _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DownServicesDefaultTypeInternal _DownServices_default_instance_;
PROTOBUF_CONSTEXPR StatusParam::StatusParam(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.status_name_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StatusParamDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StatusParamDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StatusParamDefaultTypeInternal() {}
  union {
    StatusParam _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StatusParamDefaultTypeInternal _StatusParam_default_instance_;
static ::_pb::Metadata file_level_metadata_WorkerRpcInterface_2eproto[9];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_WorkerRpcInterface_2eproto[1];
static const ::_pb::ServiceDescriptor* file_level_service_descriptors_WorkerRpcInterface_2eproto[1];

const uint32_t TableStruct_WorkerRpcInterface_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::UserServiceDescriptor, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::UserServiceDescriptor, _impl_.service_),
  PROTOBUF_FIELD_OFFSET(::UserServiceDescriptor, _impl_.alias_),
  PROTOBUF_FIELD_OFFSET(::UserServiceDescriptor, _impl_.type_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ForkInput, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ForkInput, _impl_.service_),
  PROTOBUF_FIELD_OFFSET(::ForkInput, _impl_.owner_),
  PROTOBUF_FIELD_OFFSET(::ForkInput, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::ForkInput, _impl_.alias_),
  PROTOBUF_FIELD_OFFSET(::ForkInput, _impl_.exe_params_),
  PROTOBUF_FIELD_OFFSET(::ForkInput, _impl_.docker_params_),
  PROTOBUF_FIELD_OFFSET(::ForkInput, _impl_.restart_),
  PROTOBUF_FIELD_OFFSET(::ForkInput, _impl_.port_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ForkEcho, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ForkEcho, _impl_.sd_),
  PROTOBUF_FIELD_OFFSET(::ForkEcho, _impl_.fail_),
  PROTOBUF_FIELD_OFFSET(::ForkEcho, _impl_.error_text_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ShutdownInput, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ShutdownInput, _impl_.sd_),
  PROTOBUF_FIELD_OFFSET(::ShutdownInput, _impl_.user_info_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Echo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Echo, _impl_.fail_),
  PROTOBUF_FIELD_OFFSET(::Echo, _impl_.error_text_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CheckInput, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CheckInput, _impl_.user_info_),
  PROTOBUF_FIELD_OFFSET(::CheckInput, _impl_.line_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::DownService, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::DownService, _impl_.error_text_),
  PROTOBUF_FIELD_OFFSET(::DownService, _impl_.exit_num_),
  PROTOBUF_FIELD_OFFSET(::DownService, _impl_.alias_),
  PROTOBUF_FIELD_OFFSET(::DownService, _impl_.out_file_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::DownServices, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::DownServices, _impl_.service_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::StatusParam, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::StatusParam, _impl_.status_name_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::UserServiceDescriptor)},
  { 9, -1, -1, sizeof(::ForkInput)},
  { 23, -1, -1, sizeof(::ForkEcho)},
  { 32, -1, -1, sizeof(::ShutdownInput)},
  { 40, -1, -1, sizeof(::Echo)},
  { 48, -1, -1, sizeof(::CheckInput)},
  { 56, -1, -1, sizeof(::DownService)},
  { 66, -1, -1, sizeof(::DownServices)},
  { 73, -1, -1, sizeof(::StatusParam)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::_UserServiceDescriptor_default_instance_._instance,
  &::_ForkInput_default_instance_._instance,
  &::_ForkEcho_default_instance_._instance,
  &::_ShutdownInput_default_instance_._instance,
  &::_Echo_default_instance_._instance,
  &::_CheckInput_default_instance_._instance,
  &::_DownService_default_instance_._instance,
  &::_DownServices_default_instance_._instance,
  &::_StatusParam_default_instance_._instance,
};

const char descriptor_table_protodef_WorkerRpcInterface_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\030WorkerRpcInterface.proto\"S\n\025UserServic"
  "eDescriptor\022\017\n\007service\030\001 \001(\t\022\r\n\005alias\030\002 "
  "\001(\t\022\032\n\004type\030\003 \001(\0162\014.ServiceType\"\240\001\n\tFork"
  "Input\022\017\n\007service\030\001 \001(\t\022\r\n\005owner\030\002 \001(\t\022\032\n"
  "\004type\030\003 \001(\0162\014.ServiceType\022\r\n\005alias\030\004 \001(\t"
  "\022\022\n\nexe_params\030\005 \003(\t\022\025\n\rdocker_params\030\006 "
  "\003(\t\022\017\n\007restart\030\007 \001(\005\022\014\n\004port\030\010 \001(\005\"P\n\010Fo"
  "rkEcho\022\"\n\002sd\030\001 \001(\0132\026.UserServiceDescript"
  "or\022\014\n\004fail\030\002 \001(\010\022\022\n\nerror_text\030\003 \001(\t\"F\n\r"
  "ShutdownInput\022\"\n\002sd\030\001 \001(\0132\026.UserServiceD"
  "escriptor\022\021\n\tuser_info\030\002 \001(\t\"(\n\004Echo\022\014\n\004"
  "fail\030\001 \001(\010\022\022\n\nerror_text\030\002 \001(\t\"-\n\nCheckI"
  "nput\022\021\n\tuser_info\030\001 \001(\t\022\014\n\004line\030\002 \001(\005\"T\n"
  "\013DownService\022\022\n\nerror_text\030\001 \001(\t\022\020\n\010exit"
  "_num\030\002 \001(\005\022\r\n\005alias\030\003 \001(\t\022\020\n\010out_file\030\004 "
  "\001(\t\"-\n\014DownServices\022\035\n\007service\030\001 \003(\0132\014.D"
  "ownService\"\"\n\013StatusParam\022\023\n\013status_name"
  "\030\001 \003(\t*#\n\013ServiceType\022\010\n\004host\020\000\022\n\n\006docke"
  "r\020\0012\237\001\n\rWorkerService\022\035\n\004fork\022\n.ForkInpu"
  "t\032\t.ForkEcho\022!\n\010shutdown\022\016.ShutdownInput"
  "\032\005.Echo\022#\n\005check\022\013.CheckInput\032\r.DownServ"
  "ices\022\'\n\tgetStatus\022\014.StatusParam\032\014.Status"
  "ParamB\003\200\001\001b\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_WorkerRpcInterface_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_WorkerRpcInterface_2eproto = {
    false, false, 898, descriptor_table_protodef_WorkerRpcInterface_2eproto,
    "WorkerRpcInterface.proto",
    &descriptor_table_WorkerRpcInterface_2eproto_once, nullptr, 0, 9,
    schemas, file_default_instances, TableStruct_WorkerRpcInterface_2eproto::offsets,
    file_level_metadata_WorkerRpcInterface_2eproto, file_level_enum_descriptors_WorkerRpcInterface_2eproto,
    file_level_service_descriptors_WorkerRpcInterface_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_WorkerRpcInterface_2eproto_getter() {
  return &descriptor_table_WorkerRpcInterface_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_WorkerRpcInterface_2eproto(&descriptor_table_WorkerRpcInterface_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ServiceType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_WorkerRpcInterface_2eproto);
  return file_level_enum_descriptors_WorkerRpcInterface_2eproto[0];
}
bool ServiceType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class UserServiceDescriptor::_Internal {
 public:
};

UserServiceDescriptor::UserServiceDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:UserServiceDescriptor)
}
UserServiceDescriptor::UserServiceDescriptor(const UserServiceDescriptor& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UserServiceDescriptor* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.service_){}
    , decltype(_impl_.alias_){}
    , decltype(_impl_.type_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.service_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.service_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_service().empty()) {
    _this->_impl_.service_.Set(from._internal_service(), 
      _this->GetArenaForAllocation());
  }
  _impl_.alias_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.alias_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_alias().empty()) {
    _this->_impl_.alias_.Set(from._internal_alias(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:UserServiceDescriptor)
}

inline void UserServiceDescriptor::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.service_){}
    , decltype(_impl_.alias_){}
    , decltype(_impl_.type_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.service_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.service_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.alias_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.alias_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

UserServiceDescriptor::~UserServiceDescriptor() {
  // @@protoc_insertion_point(destructor:UserServiceDescriptor)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UserServiceDescriptor::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.service_.Destroy();
  _impl_.alias_.Destroy();
}

void UserServiceDescriptor::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UserServiceDescriptor::Clear() {
// @@protoc_insertion_point(message_clear_start:UserServiceDescriptor)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.service_.ClearToEmpty();
  _impl_.alias_.ClearToEmpty();
  _impl_.type_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UserServiceDescriptor::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string service = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_service();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "UserServiceDescriptor.service"));
        } else
          goto handle_unusual;
        continue;
      // string alias = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_alias();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "UserServiceDescriptor.alias"));
        } else
          goto handle_unusual;
        continue;
      // .ServiceType type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::ServiceType>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserServiceDescriptor::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:UserServiceDescriptor)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string service = 1;
  if (!this->_internal_service().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_service().data(), static_cast<int>(this->_internal_service().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "UserServiceDescriptor.service");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_service(), target);
  }

  // string alias = 2;
  if (!this->_internal_alias().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_alias().data(), static_cast<int>(this->_internal_alias().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "UserServiceDescriptor.alias");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_alias(), target);
  }

  // .ServiceType type = 3;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:UserServiceDescriptor)
  return target;
}

size_t UserServiceDescriptor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:UserServiceDescriptor)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string service = 1;
  if (!this->_internal_service().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_service());
  }

  // string alias = 2;
  if (!this->_internal_alias().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_alias());
  }

  // .ServiceType type = 3;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UserServiceDescriptor::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UserServiceDescriptor::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UserServiceDescriptor::GetClassData() const { return &_class_data_; }


void UserServiceDescriptor::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UserServiceDescriptor*>(&to_msg);
  auto& from = static_cast<const UserServiceDescriptor&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:UserServiceDescriptor)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_service().empty()) {
    _this->_internal_set_service(from._internal_service());
  }
  if (!from._internal_alias().empty()) {
    _this->_internal_set_alias(from._internal_alias());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UserServiceDescriptor::CopyFrom(const UserServiceDescriptor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:UserServiceDescriptor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserServiceDescriptor::IsInitialized() const {
  return true;
}

void UserServiceDescriptor::InternalSwap(UserServiceDescriptor* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.service_, lhs_arena,
      &other->_impl_.service_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.alias_, lhs_arena,
      &other->_impl_.alias_, rhs_arena
  );
  swap(_impl_.type_, other->_impl_.type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UserServiceDescriptor::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_WorkerRpcInterface_2eproto_getter, &descriptor_table_WorkerRpcInterface_2eproto_once,
      file_level_metadata_WorkerRpcInterface_2eproto[0]);
}

// ===================================================================

class ForkInput::_Internal {
 public:
};

ForkInput::ForkInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ForkInput)
}
ForkInput::ForkInput(const ForkInput& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ForkInput* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.exe_params_){from._impl_.exe_params_}
    , decltype(_impl_.docker_params_){from._impl_.docker_params_}
    , decltype(_impl_.service_){}
    , decltype(_impl_.owner_){}
    , decltype(_impl_.alias_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.restart_){}
    , decltype(_impl_.port_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.service_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.service_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_service().empty()) {
    _this->_impl_.service_.Set(from._internal_service(), 
      _this->GetArenaForAllocation());
  }
  _impl_.owner_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.owner_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_owner().empty()) {
    _this->_impl_.owner_.Set(from._internal_owner(), 
      _this->GetArenaForAllocation());
  }
  _impl_.alias_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.alias_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_alias().empty()) {
    _this->_impl_.alias_.Set(from._internal_alias(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.port_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.port_));
  // @@protoc_insertion_point(copy_constructor:ForkInput)
}

inline void ForkInput::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.exe_params_){arena}
    , decltype(_impl_.docker_params_){arena}
    , decltype(_impl_.service_){}
    , decltype(_impl_.owner_){}
    , decltype(_impl_.alias_){}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.restart_){0}
    , decltype(_impl_.port_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.service_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.service_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.owner_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.owner_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.alias_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.alias_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ForkInput::~ForkInput() {
  // @@protoc_insertion_point(destructor:ForkInput)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ForkInput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.exe_params_.~RepeatedPtrField();
  _impl_.docker_params_.~RepeatedPtrField();
  _impl_.service_.Destroy();
  _impl_.owner_.Destroy();
  _impl_.alias_.Destroy();
}

void ForkInput::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ForkInput::Clear() {
// @@protoc_insertion_point(message_clear_start:ForkInput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.exe_params_.Clear();
  _impl_.docker_params_.Clear();
  _impl_.service_.ClearToEmpty();
  _impl_.owner_.ClearToEmpty();
  _impl_.alias_.ClearToEmpty();
  ::memset(&_impl_.type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.port_) -
      reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.port_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ForkInput::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string service = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_service();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "ForkInput.service"));
        } else
          goto handle_unusual;
        continue;
      // string owner = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_owner();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "ForkInput.owner"));
        } else
          goto handle_unusual;
        continue;
      // .ServiceType type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::ServiceType>(val));
        } else
          goto handle_unusual;
        continue;
      // string alias = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_alias();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "ForkInput.alias"));
        } else
          goto handle_unusual;
        continue;
      // repeated string exe_params = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_exe_params();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "ForkInput.exe_params"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string docker_params = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_docker_params();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "ForkInput.docker_params"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // int32 restart = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _impl_.restart_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 port = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ForkInput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ForkInput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string service = 1;
  if (!this->_internal_service().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_service().data(), static_cast<int>(this->_internal_service().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "ForkInput.service");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_service(), target);
  }

  // string owner = 2;
  if (!this->_internal_owner().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_owner().data(), static_cast<int>(this->_internal_owner().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "ForkInput.owner");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_owner(), target);
  }

  // .ServiceType type = 3;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_type(), target);
  }

  // string alias = 4;
  if (!this->_internal_alias().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_alias().data(), static_cast<int>(this->_internal_alias().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "ForkInput.alias");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_alias(), target);
  }

  // repeated string exe_params = 5;
  for (int i = 0, n = this->_internal_exe_params_size(); i < n; i++) {
    const auto& s = this->_internal_exe_params(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "ForkInput.exe_params");
    target = stream->WriteString(5, s, target);
  }

  // repeated string docker_params = 6;
  for (int i = 0, n = this->_internal_docker_params_size(); i < n; i++) {
    const auto& s = this->_internal_docker_params(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "ForkInput.docker_params");
    target = stream->WriteString(6, s, target);
  }

  // int32 restart = 7;
  if (this->_internal_restart() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_restart(), target);
  }

  // int32 port = 8;
  if (this->_internal_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_port(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ForkInput)
  return target;
}

size_t ForkInput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ForkInput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string exe_params = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.exe_params_.size());
  for (int i = 0, n = _impl_.exe_params_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.exe_params_.Get(i));
  }

  // repeated string docker_params = 6;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.docker_params_.size());
  for (int i = 0, n = _impl_.docker_params_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.docker_params_.Get(i));
  }

  // string service = 1;
  if (!this->_internal_service().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_service());
  }

  // string owner = 2;
  if (!this->_internal_owner().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_owner());
  }

  // string alias = 4;
  if (!this->_internal_alias().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_alias());
  }

  // .ServiceType type = 3;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  // int32 restart = 7;
  if (this->_internal_restart() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_restart());
  }

  // int32 port = 8;
  if (this->_internal_port() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_port());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ForkInput::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ForkInput::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ForkInput::GetClassData() const { return &_class_data_; }


void ForkInput::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ForkInput*>(&to_msg);
  auto& from = static_cast<const ForkInput&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ForkInput)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.exe_params_.MergeFrom(from._impl_.exe_params_);
  _this->_impl_.docker_params_.MergeFrom(from._impl_.docker_params_);
  if (!from._internal_service().empty()) {
    _this->_internal_set_service(from._internal_service());
  }
  if (!from._internal_owner().empty()) {
    _this->_internal_set_owner(from._internal_owner());
  }
  if (!from._internal_alias().empty()) {
    _this->_internal_set_alias(from._internal_alias());
  }
  if (from._internal_type() != 0) {
    _this->_internal_set_type(from._internal_type());
  }
  if (from._internal_restart() != 0) {
    _this->_internal_set_restart(from._internal_restart());
  }
  if (from._internal_port() != 0) {
    _this->_internal_set_port(from._internal_port());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ForkInput::CopyFrom(const ForkInput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ForkInput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ForkInput::IsInitialized() const {
  return true;
}

void ForkInput::InternalSwap(ForkInput* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.exe_params_.InternalSwap(&other->_impl_.exe_params_);
  _impl_.docker_params_.InternalSwap(&other->_impl_.docker_params_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.service_, lhs_arena,
      &other->_impl_.service_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.owner_, lhs_arena,
      &other->_impl_.owner_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.alias_, lhs_arena,
      &other->_impl_.alias_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ForkInput, _impl_.port_)
      + sizeof(ForkInput::_impl_.port_)
      - PROTOBUF_FIELD_OFFSET(ForkInput, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ForkInput::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_WorkerRpcInterface_2eproto_getter, &descriptor_table_WorkerRpcInterface_2eproto_once,
      file_level_metadata_WorkerRpcInterface_2eproto[1]);
}

// ===================================================================

class ForkEcho::_Internal {
 public:
  static const ::UserServiceDescriptor& sd(const ForkEcho* msg);
};

const ::UserServiceDescriptor&
ForkEcho::_Internal::sd(const ForkEcho* msg) {
  return *msg->_impl_.sd_;
}
ForkEcho::ForkEcho(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ForkEcho)
}
ForkEcho::ForkEcho(const ForkEcho& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ForkEcho* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.error_text_){}
    , decltype(_impl_.sd_){nullptr}
    , decltype(_impl_.fail_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.error_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_error_text().empty()) {
    _this->_impl_.error_text_.Set(from._internal_error_text(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_sd()) {
    _this->_impl_.sd_ = new ::UserServiceDescriptor(*from._impl_.sd_);
  }
  _this->_impl_.fail_ = from._impl_.fail_;
  // @@protoc_insertion_point(copy_constructor:ForkEcho)
}

inline void ForkEcho::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.error_text_){}
    , decltype(_impl_.sd_){nullptr}
    , decltype(_impl_.fail_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.error_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ForkEcho::~ForkEcho() {
  // @@protoc_insertion_point(destructor:ForkEcho)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ForkEcho::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.error_text_.Destroy();
  if (this != internal_default_instance()) delete _impl_.sd_;
}

void ForkEcho::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ForkEcho::Clear() {
// @@protoc_insertion_point(message_clear_start:ForkEcho)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.error_text_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.sd_ != nullptr) {
    delete _impl_.sd_;
  }
  _impl_.sd_ = nullptr;
  _impl_.fail_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ForkEcho::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .UserServiceDescriptor sd = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_sd(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool fail = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.fail_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string error_text = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_error_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "ForkEcho.error_text"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ForkEcho::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ForkEcho)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .UserServiceDescriptor sd = 1;
  if (this->_internal_has_sd()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::sd(this),
        _Internal::sd(this).GetCachedSize(), target, stream);
  }

  // bool fail = 2;
  if (this->_internal_fail() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_fail(), target);
  }

  // string error_text = 3;
  if (!this->_internal_error_text().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_error_text().data(), static_cast<int>(this->_internal_error_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "ForkEcho.error_text");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_error_text(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ForkEcho)
  return target;
}

size_t ForkEcho::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ForkEcho)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string error_text = 3;
  if (!this->_internal_error_text().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_error_text());
  }

  // .UserServiceDescriptor sd = 1;
  if (this->_internal_has_sd()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.sd_);
  }

  // bool fail = 2;
  if (this->_internal_fail() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ForkEcho::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ForkEcho::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ForkEcho::GetClassData() const { return &_class_data_; }


void ForkEcho::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ForkEcho*>(&to_msg);
  auto& from = static_cast<const ForkEcho&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ForkEcho)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_error_text().empty()) {
    _this->_internal_set_error_text(from._internal_error_text());
  }
  if (from._internal_has_sd()) {
    _this->_internal_mutable_sd()->::UserServiceDescriptor::MergeFrom(
        from._internal_sd());
  }
  if (from._internal_fail() != 0) {
    _this->_internal_set_fail(from._internal_fail());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ForkEcho::CopyFrom(const ForkEcho& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ForkEcho)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ForkEcho::IsInitialized() const {
  return true;
}

void ForkEcho::InternalSwap(ForkEcho* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.error_text_, lhs_arena,
      &other->_impl_.error_text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ForkEcho, _impl_.fail_)
      + sizeof(ForkEcho::_impl_.fail_)
      - PROTOBUF_FIELD_OFFSET(ForkEcho, _impl_.sd_)>(
          reinterpret_cast<char*>(&_impl_.sd_),
          reinterpret_cast<char*>(&other->_impl_.sd_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ForkEcho::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_WorkerRpcInterface_2eproto_getter, &descriptor_table_WorkerRpcInterface_2eproto_once,
      file_level_metadata_WorkerRpcInterface_2eproto[2]);
}

// ===================================================================

class ShutdownInput::_Internal {
 public:
  static const ::UserServiceDescriptor& sd(const ShutdownInput* msg);
};

const ::UserServiceDescriptor&
ShutdownInput::_Internal::sd(const ShutdownInput* msg) {
  return *msg->_impl_.sd_;
}
ShutdownInput::ShutdownInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ShutdownInput)
}
ShutdownInput::ShutdownInput(const ShutdownInput& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ShutdownInput* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.user_info_){}
    , decltype(_impl_.sd_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.user_info_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_info_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_user_info().empty()) {
    _this->_impl_.user_info_.Set(from._internal_user_info(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_sd()) {
    _this->_impl_.sd_ = new ::UserServiceDescriptor(*from._impl_.sd_);
  }
  // @@protoc_insertion_point(copy_constructor:ShutdownInput)
}

inline void ShutdownInput::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.user_info_){}
    , decltype(_impl_.sd_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.user_info_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_info_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ShutdownInput::~ShutdownInput() {
  // @@protoc_insertion_point(destructor:ShutdownInput)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShutdownInput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.user_info_.Destroy();
  if (this != internal_default_instance()) delete _impl_.sd_;
}

void ShutdownInput::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ShutdownInput::Clear() {
// @@protoc_insertion_point(message_clear_start:ShutdownInput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.user_info_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && _impl_.sd_ != nullptr) {
    delete _impl_.sd_;
  }
  _impl_.sd_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShutdownInput::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .UserServiceDescriptor sd = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_sd(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string user_info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_user_info();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "ShutdownInput.user_info"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShutdownInput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ShutdownInput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .UserServiceDescriptor sd = 1;
  if (this->_internal_has_sd()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::sd(this),
        _Internal::sd(this).GetCachedSize(), target, stream);
  }

  // string user_info = 2;
  if (!this->_internal_user_info().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_user_info().data(), static_cast<int>(this->_internal_user_info().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "ShutdownInput.user_info");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_user_info(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ShutdownInput)
  return target;
}

size_t ShutdownInput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ShutdownInput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string user_info = 2;
  if (!this->_internal_user_info().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_info());
  }

  // .UserServiceDescriptor sd = 1;
  if (this->_internal_has_sd()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.sd_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShutdownInput::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ShutdownInput::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShutdownInput::GetClassData() const { return &_class_data_; }


void ShutdownInput::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ShutdownInput*>(&to_msg);
  auto& from = static_cast<const ShutdownInput&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ShutdownInput)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_user_info().empty()) {
    _this->_internal_set_user_info(from._internal_user_info());
  }
  if (from._internal_has_sd()) {
    _this->_internal_mutable_sd()->::UserServiceDescriptor::MergeFrom(
        from._internal_sd());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShutdownInput::CopyFrom(const ShutdownInput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ShutdownInput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShutdownInput::IsInitialized() const {
  return true;
}

void ShutdownInput::InternalSwap(ShutdownInput* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_info_, lhs_arena,
      &other->_impl_.user_info_, rhs_arena
  );
  swap(_impl_.sd_, other->_impl_.sd_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ShutdownInput::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_WorkerRpcInterface_2eproto_getter, &descriptor_table_WorkerRpcInterface_2eproto_once,
      file_level_metadata_WorkerRpcInterface_2eproto[3]);
}

// ===================================================================

class Echo::_Internal {
 public:
};

Echo::Echo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:Echo)
}
Echo::Echo(const Echo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Echo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.error_text_){}
    , decltype(_impl_.fail_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.error_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_error_text().empty()) {
    _this->_impl_.error_text_.Set(from._internal_error_text(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.fail_ = from._impl_.fail_;
  // @@protoc_insertion_point(copy_constructor:Echo)
}

inline void Echo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.error_text_){}
    , decltype(_impl_.fail_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.error_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Echo::~Echo() {
  // @@protoc_insertion_point(destructor:Echo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Echo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.error_text_.Destroy();
}

void Echo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Echo::Clear() {
// @@protoc_insertion_point(message_clear_start:Echo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.error_text_.ClearToEmpty();
  _impl_.fail_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Echo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool fail = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.fail_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string error_text = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_error_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "Echo.error_text"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Echo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Echo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool fail = 1;
  if (this->_internal_fail() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_fail(), target);
  }

  // string error_text = 2;
  if (!this->_internal_error_text().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_error_text().data(), static_cast<int>(this->_internal_error_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Echo.error_text");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_error_text(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Echo)
  return target;
}

size_t Echo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Echo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string error_text = 2;
  if (!this->_internal_error_text().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_error_text());
  }

  // bool fail = 1;
  if (this->_internal_fail() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Echo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Echo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Echo::GetClassData() const { return &_class_data_; }


void Echo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Echo*>(&to_msg);
  auto& from = static_cast<const Echo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:Echo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_error_text().empty()) {
    _this->_internal_set_error_text(from._internal_error_text());
  }
  if (from._internal_fail() != 0) {
    _this->_internal_set_fail(from._internal_fail());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Echo::CopyFrom(const Echo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Echo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Echo::IsInitialized() const {
  return true;
}

void Echo::InternalSwap(Echo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.error_text_, lhs_arena,
      &other->_impl_.error_text_, rhs_arena
  );
  swap(_impl_.fail_, other->_impl_.fail_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Echo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_WorkerRpcInterface_2eproto_getter, &descriptor_table_WorkerRpcInterface_2eproto_once,
      file_level_metadata_WorkerRpcInterface_2eproto[4]);
}

// ===================================================================

class CheckInput::_Internal {
 public:
};

CheckInput::CheckInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CheckInput)
}
CheckInput::CheckInput(const CheckInput& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CheckInput* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.user_info_){}
    , decltype(_impl_.line_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.user_info_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_info_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_user_info().empty()) {
    _this->_impl_.user_info_.Set(from._internal_user_info(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.line_ = from._impl_.line_;
  // @@protoc_insertion_point(copy_constructor:CheckInput)
}

inline void CheckInput::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.user_info_){}
    , decltype(_impl_.line_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.user_info_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.user_info_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CheckInput::~CheckInput() {
  // @@protoc_insertion_point(destructor:CheckInput)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CheckInput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.user_info_.Destroy();
}

void CheckInput::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CheckInput::Clear() {
// @@protoc_insertion_point(message_clear_start:CheckInput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.user_info_.ClearToEmpty();
  _impl_.line_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CheckInput::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string user_info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_info();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "CheckInput.user_info"));
        } else
          goto handle_unusual;
        continue;
      // int32 line = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.line_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CheckInput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CheckInput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string user_info = 1;
  if (!this->_internal_user_info().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_user_info().data(), static_cast<int>(this->_internal_user_info().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CheckInput.user_info");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_info(), target);
  }

  // int32 line = 2;
  if (this->_internal_line() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_line(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CheckInput)
  return target;
}

size_t CheckInput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CheckInput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string user_info = 1;
  if (!this->_internal_user_info().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_info());
  }

  // int32 line = 2;
  if (this->_internal_line() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_line());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CheckInput::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CheckInput::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CheckInput::GetClassData() const { return &_class_data_; }


void CheckInput::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CheckInput*>(&to_msg);
  auto& from = static_cast<const CheckInput&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CheckInput)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_user_info().empty()) {
    _this->_internal_set_user_info(from._internal_user_info());
  }
  if (from._internal_line() != 0) {
    _this->_internal_set_line(from._internal_line());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CheckInput::CopyFrom(const CheckInput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CheckInput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckInput::IsInitialized() const {
  return true;
}

void CheckInput::InternalSwap(CheckInput* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.user_info_, lhs_arena,
      &other->_impl_.user_info_, rhs_arena
  );
  swap(_impl_.line_, other->_impl_.line_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CheckInput::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_WorkerRpcInterface_2eproto_getter, &descriptor_table_WorkerRpcInterface_2eproto_once,
      file_level_metadata_WorkerRpcInterface_2eproto[5]);
}

// ===================================================================

class DownService::_Internal {
 public:
};

DownService::DownService(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:DownService)
}
DownService::DownService(const DownService& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DownService* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.error_text_){}
    , decltype(_impl_.alias_){}
    , decltype(_impl_.out_file_){}
    , decltype(_impl_.exit_num_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.error_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_error_text().empty()) {
    _this->_impl_.error_text_.Set(from._internal_error_text(), 
      _this->GetArenaForAllocation());
  }
  _impl_.alias_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.alias_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_alias().empty()) {
    _this->_impl_.alias_.Set(from._internal_alias(), 
      _this->GetArenaForAllocation());
  }
  _impl_.out_file_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.out_file_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_out_file().empty()) {
    _this->_impl_.out_file_.Set(from._internal_out_file(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.exit_num_ = from._impl_.exit_num_;
  // @@protoc_insertion_point(copy_constructor:DownService)
}

inline void DownService::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.error_text_){}
    , decltype(_impl_.alias_){}
    , decltype(_impl_.out_file_){}
    , decltype(_impl_.exit_num_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.error_text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.error_text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.alias_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.alias_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.out_file_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.out_file_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DownService::~DownService() {
  // @@protoc_insertion_point(destructor:DownService)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DownService::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.error_text_.Destroy();
  _impl_.alias_.Destroy();
  _impl_.out_file_.Destroy();
}

void DownService::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DownService::Clear() {
// @@protoc_insertion_point(message_clear_start:DownService)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.error_text_.ClearToEmpty();
  _impl_.alias_.ClearToEmpty();
  _impl_.out_file_.ClearToEmpty();
  _impl_.exit_num_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DownService::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string error_text = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_error_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "DownService.error_text"));
        } else
          goto handle_unusual;
        continue;
      // int32 exit_num = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.exit_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string alias = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_alias();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "DownService.alias"));
        } else
          goto handle_unusual;
        continue;
      // string out_file = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_out_file();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "DownService.out_file"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DownService::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DownService)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string error_text = 1;
  if (!this->_internal_error_text().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_error_text().data(), static_cast<int>(this->_internal_error_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "DownService.error_text");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_error_text(), target);
  }

  // int32 exit_num = 2;
  if (this->_internal_exit_num() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_exit_num(), target);
  }

  // string alias = 3;
  if (!this->_internal_alias().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_alias().data(), static_cast<int>(this->_internal_alias().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "DownService.alias");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_alias(), target);
  }

  // string out_file = 4;
  if (!this->_internal_out_file().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_out_file().data(), static_cast<int>(this->_internal_out_file().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "DownService.out_file");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_out_file(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DownService)
  return target;
}

size_t DownService::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DownService)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string error_text = 1;
  if (!this->_internal_error_text().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_error_text());
  }

  // string alias = 3;
  if (!this->_internal_alias().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_alias());
  }

  // string out_file = 4;
  if (!this->_internal_out_file().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_out_file());
  }

  // int32 exit_num = 2;
  if (this->_internal_exit_num() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_exit_num());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DownService::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DownService::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DownService::GetClassData() const { return &_class_data_; }


void DownService::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DownService*>(&to_msg);
  auto& from = static_cast<const DownService&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:DownService)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_error_text().empty()) {
    _this->_internal_set_error_text(from._internal_error_text());
  }
  if (!from._internal_alias().empty()) {
    _this->_internal_set_alias(from._internal_alias());
  }
  if (!from._internal_out_file().empty()) {
    _this->_internal_set_out_file(from._internal_out_file());
  }
  if (from._internal_exit_num() != 0) {
    _this->_internal_set_exit_num(from._internal_exit_num());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DownService::CopyFrom(const DownService& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DownService)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DownService::IsInitialized() const {
  return true;
}

void DownService::InternalSwap(DownService* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.error_text_, lhs_arena,
      &other->_impl_.error_text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.alias_, lhs_arena,
      &other->_impl_.alias_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.out_file_, lhs_arena,
      &other->_impl_.out_file_, rhs_arena
  );
  swap(_impl_.exit_num_, other->_impl_.exit_num_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DownService::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_WorkerRpcInterface_2eproto_getter, &descriptor_table_WorkerRpcInterface_2eproto_once,
      file_level_metadata_WorkerRpcInterface_2eproto[6]);
}

// ===================================================================

class DownServices::_Internal {
 public:
};

DownServices::DownServices(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:DownServices)
}
DownServices::DownServices(const DownServices& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DownServices* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.service_){from._impl_.service_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:DownServices)
}

inline void DownServices::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.service_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DownServices::~DownServices() {
  // @@protoc_insertion_point(destructor:DownServices)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DownServices::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.service_.~RepeatedPtrField();
}

void DownServices::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DownServices::Clear() {
// @@protoc_insertion_point(message_clear_start:DownServices)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.service_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DownServices::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .DownService service = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_service(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DownServices::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DownServices)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .DownService service = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_service_size()); i < n; i++) {
    const auto& repfield = this->_internal_service(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DownServices)
  return target;
}

size_t DownServices::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DownServices)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .DownService service = 1;
  total_size += 1UL * this->_internal_service_size();
  for (const auto& msg : this->_impl_.service_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DownServices::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DownServices::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DownServices::GetClassData() const { return &_class_data_; }


void DownServices::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DownServices*>(&to_msg);
  auto& from = static_cast<const DownServices&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:DownServices)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.service_.MergeFrom(from._impl_.service_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DownServices::CopyFrom(const DownServices& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DownServices)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DownServices::IsInitialized() const {
  return true;
}

void DownServices::InternalSwap(DownServices* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.service_.InternalSwap(&other->_impl_.service_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DownServices::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_WorkerRpcInterface_2eproto_getter, &descriptor_table_WorkerRpcInterface_2eproto_once,
      file_level_metadata_WorkerRpcInterface_2eproto[7]);
}

// ===================================================================

class StatusParam::_Internal {
 public:
};

StatusParam::StatusParam(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:StatusParam)
}
StatusParam::StatusParam(const StatusParam& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StatusParam* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.status_name_){from._impl_.status_name_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:StatusParam)
}

inline void StatusParam::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.status_name_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StatusParam::~StatusParam() {
  // @@protoc_insertion_point(destructor:StatusParam)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StatusParam::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.status_name_.~RepeatedPtrField();
}

void StatusParam::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StatusParam::Clear() {
// @@protoc_insertion_point(message_clear_start:StatusParam)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.status_name_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StatusParam::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string status_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_status_name();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "StatusParam.status_name"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StatusParam::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:StatusParam)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string status_name = 1;
  for (int i = 0, n = this->_internal_status_name_size(); i < n; i++) {
    const auto& s = this->_internal_status_name(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "StatusParam.status_name");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:StatusParam)
  return target;
}

size_t StatusParam::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:StatusParam)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string status_name = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.status_name_.size());
  for (int i = 0, n = _impl_.status_name_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.status_name_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StatusParam::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StatusParam::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StatusParam::GetClassData() const { return &_class_data_; }


void StatusParam::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StatusParam*>(&to_msg);
  auto& from = static_cast<const StatusParam&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:StatusParam)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.status_name_.MergeFrom(from._impl_.status_name_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StatusParam::CopyFrom(const StatusParam& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:StatusParam)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StatusParam::IsInitialized() const {
  return true;
}

void StatusParam::InternalSwap(StatusParam* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.status_name_.InternalSwap(&other->_impl_.status_name_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StatusParam::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_WorkerRpcInterface_2eproto_getter, &descriptor_table_WorkerRpcInterface_2eproto_once,
      file_level_metadata_WorkerRpcInterface_2eproto[8]);
}

// ===================================================================

WorkerService::~WorkerService() {}

const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* WorkerService::descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_WorkerRpcInterface_2eproto);
  return file_level_service_descriptors_WorkerRpcInterface_2eproto[0];
}

const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* WorkerService::GetDescriptor() {
  return descriptor();
}

void WorkerService::fork(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::ForkInput*,
                         ::ForkEcho*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method fork() not implemented.");
  done->Run();
}

void WorkerService::shutdown(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::ShutdownInput*,
                         ::Echo*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method shutdown() not implemented.");
  done->Run();
}

void WorkerService::check(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CheckInput*,
                         ::DownServices*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method check() not implemented.");
  done->Run();
}

void WorkerService::getStatus(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::StatusParam*,
                         ::StatusParam*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method getStatus() not implemented.");
  done->Run();
}

void WorkerService::CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                             ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                             const ::PROTOBUF_NAMESPACE_ID::Message* request,
                             ::PROTOBUF_NAMESPACE_ID::Message* response,
                             ::google::protobuf::Closure* done) {
  GOOGLE_DCHECK_EQ(method->service(), file_level_service_descriptors_WorkerRpcInterface_2eproto[0]);
  switch(method->index()) {
    case 0:
      fork(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::ForkInput*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::ForkEcho*>(
                 response),
             done);
      break;
    case 1:
      shutdown(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::ShutdownInput*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::Echo*>(
                 response),
             done);
      break;
    case 2:
      check(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CheckInput*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::DownServices*>(
                 response),
             done);
      break;
    case 3:
      getStatus(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::StatusParam*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::StatusParam*>(
                 response),
             done);
      break;
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      break;
  }
}

const ::PROTOBUF_NAMESPACE_ID::Message& WorkerService::GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::ForkInput::default_instance();
    case 1:
      return ::ShutdownInput::default_instance();
    case 2:
      return ::CheckInput::default_instance();
    case 3:
      return ::StatusParam::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::PROTOBUF_NAMESPACE_ID::MessageFactory::generated_factory()
          ->GetPrototype(method->input_type());
  }
}

const ::PROTOBUF_NAMESPACE_ID::Message& WorkerService::GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::ForkEcho::default_instance();
    case 1:
      return ::Echo::default_instance();
    case 2:
      return ::DownServices::default_instance();
    case 3:
      return ::StatusParam::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::PROTOBUF_NAMESPACE_ID::MessageFactory::generated_factory()
          ->GetPrototype(method->output_type());
  }
}

WorkerService_Stub::WorkerService_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel)
  : channel_(channel), owns_channel_(false) {}
WorkerService_Stub::WorkerService_Stub(
    ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
    ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership)
  : channel_(channel),
    owns_channel_(ownership == ::PROTOBUF_NAMESPACE_ID::Service::STUB_OWNS_CHANNEL) {}
WorkerService_Stub::~WorkerService_Stub() {
  if (owns_channel_) delete channel_;
}

void WorkerService_Stub::fork(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::ForkInput* request,
                              ::ForkEcho* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(0),
                       controller, request, response, done);
}
void WorkerService_Stub::shutdown(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::ShutdownInput* request,
                              ::Echo* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(1),
                       controller, request, response, done);
}
void WorkerService_Stub::check(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CheckInput* request,
                              ::DownServices* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(2),
                       controller, request, response, done);
}
void WorkerService_Stub::getStatus(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::StatusParam* request,
                              ::StatusParam* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(3),
                       controller, request, response, done);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::UserServiceDescriptor*
Arena::CreateMaybeMessage< ::UserServiceDescriptor >(Arena* arena) {
  return Arena::CreateMessageInternal< ::UserServiceDescriptor >(arena);
}
template<> PROTOBUF_NOINLINE ::ForkInput*
Arena::CreateMaybeMessage< ::ForkInput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ForkInput >(arena);
}
template<> PROTOBUF_NOINLINE ::ForkEcho*
Arena::CreateMaybeMessage< ::ForkEcho >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ForkEcho >(arena);
}
template<> PROTOBUF_NOINLINE ::ShutdownInput*
Arena::CreateMaybeMessage< ::ShutdownInput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ShutdownInput >(arena);
}
template<> PROTOBUF_NOINLINE ::Echo*
Arena::CreateMaybeMessage< ::Echo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Echo >(arena);
}
template<> PROTOBUF_NOINLINE ::CheckInput*
Arena::CreateMaybeMessage< ::CheckInput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CheckInput >(arena);
}
template<> PROTOBUF_NOINLINE ::DownService*
Arena::CreateMaybeMessage< ::DownService >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DownService >(arena);
}
template<> PROTOBUF_NOINLINE ::DownServices*
Arena::CreateMaybeMessage< ::DownServices >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DownServices >(arena);
}
template<> PROTOBUF_NOINLINE ::StatusParam*
Arena::CreateMaybeMessage< ::StatusParam >(Arena* arena) {
  return Arena::CreateMessageInternal< ::StatusParam >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
