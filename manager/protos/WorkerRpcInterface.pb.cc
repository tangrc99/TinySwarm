// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: WorkerRpcInterface.proto

#include "WorkerRpcInterface.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
constexpr UserServiceDescriptor::UserServiceDescriptor(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : service_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , alias_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , type_(0)
{}
struct UserServiceDescriptorDefaultTypeInternal {
  constexpr UserServiceDescriptorDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~UserServiceDescriptorDefaultTypeInternal() {}
  union {
    UserServiceDescriptor _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT UserServiceDescriptorDefaultTypeInternal _UserServiceDescriptor_default_instance_;
constexpr ForkInput::ForkInput(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : exe_params_()
  , docker_params_()
  , service_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , owner_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , alias_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , type_(0)

  , restart_(0){}
struct ForkInputDefaultTypeInternal {
  constexpr ForkInputDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ForkInputDefaultTypeInternal() {}
  union {
    ForkInput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ForkInputDefaultTypeInternal _ForkInput_default_instance_;
constexpr ForkEcho::ForkEcho(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : error_text_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , sd_(nullptr)
  , fail_(false){}
struct ForkEchoDefaultTypeInternal {
  constexpr ForkEchoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ForkEchoDefaultTypeInternal() {}
  union {
    ForkEcho _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ForkEchoDefaultTypeInternal _ForkEcho_default_instance_;
constexpr ShutdownInput::ShutdownInput(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_info_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , sd_(nullptr){}
struct ShutdownInputDefaultTypeInternal {
  constexpr ShutdownInputDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~ShutdownInputDefaultTypeInternal() {}
  union {
    ShutdownInput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT ShutdownInputDefaultTypeInternal _ShutdownInput_default_instance_;
constexpr Echo::Echo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : error_text_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , fail_(false){}
struct EchoDefaultTypeInternal {
  constexpr EchoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~EchoDefaultTypeInternal() {}
  union {
    Echo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT EchoDefaultTypeInternal _Echo_default_instance_;
constexpr CheckInput::CheckInput(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_info_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , line_(0){}
struct CheckInputDefaultTypeInternal {
  constexpr CheckInputDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CheckInputDefaultTypeInternal() {}
  union {
    CheckInput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CheckInputDefaultTypeInternal _CheckInput_default_instance_;
constexpr DownService::DownService(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : error_text_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , alias_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , out_file_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , exit_num_(0){}
struct DownServiceDefaultTypeInternal {
  constexpr DownServiceDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DownServiceDefaultTypeInternal() {}
  union {
    DownService _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DownServiceDefaultTypeInternal _DownService_default_instance_;
constexpr DownServices::DownServices(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : service_(){}
struct DownServicesDefaultTypeInternal {
  constexpr DownServicesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~DownServicesDefaultTypeInternal() {}
  union {
    DownServices _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT DownServicesDefaultTypeInternal _DownServices_default_instance_;
constexpr PushInput::PushInput(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : service_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , bin_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct PushInputDefaultTypeInternal {
  constexpr PushInputDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~PushInputDefaultTypeInternal() {}
  union {
    PushInput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PushInputDefaultTypeInternal _PushInput_default_instance_;
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_WorkerRpcInterface_2eproto[9];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_WorkerRpcInterface_2eproto[1];
static const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* file_level_service_descriptors_WorkerRpcInterface_2eproto[1];

const uint32_t TableStruct_WorkerRpcInterface_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::UserServiceDescriptor, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::UserServiceDescriptor, service_),
  PROTOBUF_FIELD_OFFSET(::UserServiceDescriptor, alias_),
  PROTOBUF_FIELD_OFFSET(::UserServiceDescriptor, type_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ForkInput, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ForkInput, service_),
  PROTOBUF_FIELD_OFFSET(::ForkInput, owner_),
  PROTOBUF_FIELD_OFFSET(::ForkInput, type_),
  PROTOBUF_FIELD_OFFSET(::ForkInput, alias_),
  PROTOBUF_FIELD_OFFSET(::ForkInput, exe_params_),
  PROTOBUF_FIELD_OFFSET(::ForkInput, docker_params_),
  PROTOBUF_FIELD_OFFSET(::ForkInput, restart_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ForkEcho, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ForkEcho, sd_),
  PROTOBUF_FIELD_OFFSET(::ForkEcho, fail_),
  PROTOBUF_FIELD_OFFSET(::ForkEcho, error_text_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ShutdownInput, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ShutdownInput, sd_),
  PROTOBUF_FIELD_OFFSET(::ShutdownInput, user_info_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::Echo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::Echo, fail_),
  PROTOBUF_FIELD_OFFSET(::Echo, error_text_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CheckInput, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CheckInput, user_info_),
  PROTOBUF_FIELD_OFFSET(::CheckInput, line_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::DownService, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::DownService, error_text_),
  PROTOBUF_FIELD_OFFSET(::DownService, exit_num_),
  PROTOBUF_FIELD_OFFSET(::DownService, alias_),
  PROTOBUF_FIELD_OFFSET(::DownService, out_file_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::DownServices, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::DownServices, service_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::PushInput, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::PushInput, service_),
  PROTOBUF_FIELD_OFFSET(::PushInput, bin_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::UserServiceDescriptor)},
  { 9, -1, -1, sizeof(::ForkInput)},
  { 22, -1, -1, sizeof(::ForkEcho)},
  { 31, -1, -1, sizeof(::ShutdownInput)},
  { 39, -1, -1, sizeof(::Echo)},
  { 47, -1, -1, sizeof(::CheckInput)},
  { 55, -1, -1, sizeof(::DownService)},
  { 65, -1, -1, sizeof(::DownServices)},
  { 72, -1, -1, sizeof(::PushInput)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_UserServiceDescriptor_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_ForkInput_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_ForkEcho_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_ShutdownInput_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_Echo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CheckInput_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_DownService_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_DownServices_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_PushInput_default_instance_),
};

const char descriptor_table_protodef_WorkerRpcInterface_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\030WorkerRpcInterface.proto\"S\n\025UserServic"
  "eDescriptor\022\017\n\007service\030\001 \001(\t\022\r\n\005alias\030\002 "
  "\001(\t\022\032\n\004type\030\003 \001(\0162\014.ServiceType\"\222\001\n\tFork"
  "Input\022\017\n\007service\030\001 \001(\t\022\r\n\005owner\030\002 \001(\t\022\032\n"
  "\004type\030\003 \001(\0162\014.ServiceType\022\r\n\005alias\030\004 \001(\t"
  "\022\022\n\nexe_params\030\005 \003(\t\022\025\n\rdocker_params\030\006 "
  "\003(\t\022\017\n\007restart\030\007 \001(\005\"P\n\010ForkEcho\022\"\n\002sd\030\001"
  " \001(\0132\026.UserServiceDescriptor\022\014\n\004fail\030\002 \001"
  "(\010\022\022\n\nerror_text\030\003 \001(\t\"F\n\rShutdownInput\022"
  "\"\n\002sd\030\001 \001(\0132\026.UserServiceDescriptor\022\021\n\tu"
  "ser_info\030\002 \001(\t\"(\n\004Echo\022\014\n\004fail\030\001 \001(\010\022\022\n\n"
  "error_text\030\002 \001(\t\"-\n\nCheckInput\022\021\n\tuser_i"
  "nfo\030\001 \001(\t\022\014\n\004line\030\002 \001(\005\"T\n\013DownService\022\022"
  "\n\nerror_text\030\001 \001(\t\022\020\n\010exit_num\030\002 \001(\005\022\r\n\005"
  "alias\030\003 \001(\t\022\020\n\010out_file\030\004 \001(\t\"-\n\014DownSer"
  "vices\022\035\n\007service\030\001 \003(\0132\014.DownService\")\n\t"
  "PushInput\022\017\n\007service\030\001 \001(\t\022\013\n\003bin\030\002 \001(\014*"
  "#\n\013ServiceType\022\010\n\004host\020\000\022\n\n\006docker\020\0012\221\001\n"
  "\rWorkerService\022\035\n\004fork\022\n.ForkInput\032\t.For"
  "kEcho\022!\n\010shutdown\022\016.ShutdownInput\032\005.Echo"
  "\022#\n\005check\022\013.CheckInput\032\r.DownServices\022\031\n"
  "\004push\022\n.PushInput\032\005.EchoB\003\200\001\001b\006proto3"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_WorkerRpcInterface_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_WorkerRpcInterface_2eproto = {
  false, false, 877, descriptor_table_protodef_WorkerRpcInterface_2eproto, "WorkerRpcInterface.proto", 
  &descriptor_table_WorkerRpcInterface_2eproto_once, nullptr, 0, 9,
  schemas, file_default_instances, TableStruct_WorkerRpcInterface_2eproto::offsets,
  file_level_metadata_WorkerRpcInterface_2eproto, file_level_enum_descriptors_WorkerRpcInterface_2eproto, file_level_service_descriptors_WorkerRpcInterface_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_WorkerRpcInterface_2eproto_getter() {
  return &descriptor_table_WorkerRpcInterface_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_WorkerRpcInterface_2eproto(&descriptor_table_WorkerRpcInterface_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ServiceType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_WorkerRpcInterface_2eproto);
  return file_level_enum_descriptors_WorkerRpcInterface_2eproto[0];
}
bool ServiceType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class UserServiceDescriptor::_Internal {
 public:
};

UserServiceDescriptor::UserServiceDescriptor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:UserServiceDescriptor)
}
UserServiceDescriptor::UserServiceDescriptor(const UserServiceDescriptor& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  service_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    service_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_service().empty()) {
    service_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_service(), 
      GetArenaForAllocation());
  }
  alias_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    alias_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_alias().empty()) {
    alias_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_alias(), 
      GetArenaForAllocation());
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:UserServiceDescriptor)
}

inline void UserServiceDescriptor::SharedCtor() {
service_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  service_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
alias_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  alias_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
type_ = 0;
}

UserServiceDescriptor::~UserServiceDescriptor() {
  // @@protoc_insertion_point(destructor:UserServiceDescriptor)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void UserServiceDescriptor::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  service_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  alias_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void UserServiceDescriptor::ArenaDtor(void* object) {
  UserServiceDescriptor* _this = reinterpret_cast< UserServiceDescriptor* >(object);
  (void)_this;
}
void UserServiceDescriptor::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void UserServiceDescriptor::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void UserServiceDescriptor::Clear() {
// @@protoc_insertion_point(message_clear_start:UserServiceDescriptor)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  service_.ClearToEmpty();
  alias_.ClearToEmpty();
  type_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UserServiceDescriptor::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string service = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_service();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "UserServiceDescriptor.service"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string alias = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_alias();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "UserServiceDescriptor.alias"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .ServiceType type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::ServiceType>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* UserServiceDescriptor::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:UserServiceDescriptor)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string service = 1;
  if (!this->_internal_service().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_service().data(), static_cast<int>(this->_internal_service().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "UserServiceDescriptor.service");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_service(), target);
  }

  // string alias = 2;
  if (!this->_internal_alias().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_alias().data(), static_cast<int>(this->_internal_alias().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "UserServiceDescriptor.alias");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_alias(), target);
  }

  // .ServiceType type = 3;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:UserServiceDescriptor)
  return target;
}

size_t UserServiceDescriptor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:UserServiceDescriptor)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string service = 1;
  if (!this->_internal_service().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_service());
  }

  // string alias = 2;
  if (!this->_internal_alias().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_alias());
  }

  // .ServiceType type = 3;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UserServiceDescriptor::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    UserServiceDescriptor::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UserServiceDescriptor::GetClassData() const { return &_class_data_; }

void UserServiceDescriptor::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<UserServiceDescriptor *>(to)->MergeFrom(
      static_cast<const UserServiceDescriptor &>(from));
}


void UserServiceDescriptor::MergeFrom(const UserServiceDescriptor& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:UserServiceDescriptor)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_service().empty()) {
    _internal_set_service(from._internal_service());
  }
  if (!from._internal_alias().empty()) {
    _internal_set_alias(from._internal_alias());
  }
  if (from._internal_type() != 0) {
    _internal_set_type(from._internal_type());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UserServiceDescriptor::CopyFrom(const UserServiceDescriptor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:UserServiceDescriptor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UserServiceDescriptor::IsInitialized() const {
  return true;
}

void UserServiceDescriptor::InternalSwap(UserServiceDescriptor* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &service_, lhs_arena,
      &other->service_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &alias_, lhs_arena,
      &other->alias_, rhs_arena
  );
  swap(type_, other->type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata UserServiceDescriptor::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_WorkerRpcInterface_2eproto_getter, &descriptor_table_WorkerRpcInterface_2eproto_once,
      file_level_metadata_WorkerRpcInterface_2eproto[0]);
}

// ===================================================================

class ForkInput::_Internal {
 public:
};

ForkInput::ForkInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  exe_params_(arena),
  docker_params_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:ForkInput)
}
ForkInput::ForkInput(const ForkInput& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      exe_params_(from.exe_params_),
      docker_params_(from.docker_params_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  service_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    service_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_service().empty()) {
    service_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_service(), 
      GetArenaForAllocation());
  }
  owner_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    owner_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_owner().empty()) {
    owner_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_owner(), 
      GetArenaForAllocation());
  }
  alias_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    alias_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_alias().empty()) {
    alias_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_alias(), 
      GetArenaForAllocation());
  }
  ::memcpy(&type_, &from.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&restart_) -
    reinterpret_cast<char*>(&type_)) + sizeof(restart_));
  // @@protoc_insertion_point(copy_constructor:ForkInput)
}

inline void ForkInput::SharedCtor() {
service_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  service_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
owner_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  owner_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
alias_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  alias_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&type_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&restart_) -
    reinterpret_cast<char*>(&type_)) + sizeof(restart_));
}

ForkInput::~ForkInput() {
  // @@protoc_insertion_point(destructor:ForkInput)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ForkInput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  service_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  owner_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  alias_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void ForkInput::ArenaDtor(void* object) {
  ForkInput* _this = reinterpret_cast< ForkInput* >(object);
  (void)_this;
}
void ForkInput::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ForkInput::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ForkInput::Clear() {
// @@protoc_insertion_point(message_clear_start:ForkInput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  exe_params_.Clear();
  docker_params_.Clear();
  service_.ClearToEmpty();
  owner_.ClearToEmpty();
  alias_.ClearToEmpty();
  ::memset(&type_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&restart_) -
      reinterpret_cast<char*>(&type_)) + sizeof(restart_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ForkInput::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string service = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_service();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "ForkInput.service"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string owner = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_owner();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "ForkInput.owner"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .ServiceType type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::ServiceType>(val));
        } else
          goto handle_unusual;
        continue;
      // string alias = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_alias();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "ForkInput.alias"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string exe_params = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_exe_params();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "ForkInput.exe_params"));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string docker_params = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_docker_params();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "ForkInput.docker_params"));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // int32 restart = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          restart_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ForkInput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ForkInput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string service = 1;
  if (!this->_internal_service().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_service().data(), static_cast<int>(this->_internal_service().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "ForkInput.service");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_service(), target);
  }

  // string owner = 2;
  if (!this->_internal_owner().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_owner().data(), static_cast<int>(this->_internal_owner().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "ForkInput.owner");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_owner(), target);
  }

  // .ServiceType type = 3;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_type(), target);
  }

  // string alias = 4;
  if (!this->_internal_alias().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_alias().data(), static_cast<int>(this->_internal_alias().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "ForkInput.alias");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_alias(), target);
  }

  // repeated string exe_params = 5;
  for (int i = 0, n = this->_internal_exe_params_size(); i < n; i++) {
    const auto& s = this->_internal_exe_params(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "ForkInput.exe_params");
    target = stream->WriteString(5, s, target);
  }

  // repeated string docker_params = 6;
  for (int i = 0, n = this->_internal_docker_params_size(); i < n; i++) {
    const auto& s = this->_internal_docker_params(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "ForkInput.docker_params");
    target = stream->WriteString(6, s, target);
  }

  // int32 restart = 7;
  if (this->_internal_restart() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(7, this->_internal_restart(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ForkInput)
  return target;
}

size_t ForkInput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ForkInput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string exe_params = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(exe_params_.size());
  for (int i = 0, n = exe_params_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      exe_params_.Get(i));
  }

  // repeated string docker_params = 6;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(docker_params_.size());
  for (int i = 0, n = docker_params_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      docker_params_.Get(i));
  }

  // string service = 1;
  if (!this->_internal_service().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_service());
  }

  // string owner = 2;
  if (!this->_internal_owner().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_owner());
  }

  // string alias = 4;
  if (!this->_internal_alias().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_alias());
  }

  // .ServiceType type = 3;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }

  // int32 restart = 7;
  if (this->_internal_restart() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_restart());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ForkInput::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ForkInput::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ForkInput::GetClassData() const { return &_class_data_; }

void ForkInput::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ForkInput *>(to)->MergeFrom(
      static_cast<const ForkInput &>(from));
}


void ForkInput::MergeFrom(const ForkInput& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ForkInput)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  exe_params_.MergeFrom(from.exe_params_);
  docker_params_.MergeFrom(from.docker_params_);
  if (!from._internal_service().empty()) {
    _internal_set_service(from._internal_service());
  }
  if (!from._internal_owner().empty()) {
    _internal_set_owner(from._internal_owner());
  }
  if (!from._internal_alias().empty()) {
    _internal_set_alias(from._internal_alias());
  }
  if (from._internal_type() != 0) {
    _internal_set_type(from._internal_type());
  }
  if (from._internal_restart() != 0) {
    _internal_set_restart(from._internal_restart());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ForkInput::CopyFrom(const ForkInput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ForkInput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ForkInput::IsInitialized() const {
  return true;
}

void ForkInput::InternalSwap(ForkInput* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  exe_params_.InternalSwap(&other->exe_params_);
  docker_params_.InternalSwap(&other->docker_params_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &service_, lhs_arena,
      &other->service_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &owner_, lhs_arena,
      &other->owner_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &alias_, lhs_arena,
      &other->alias_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ForkInput, restart_)
      + sizeof(ForkInput::restart_)
      - PROTOBUF_FIELD_OFFSET(ForkInput, type_)>(
          reinterpret_cast<char*>(&type_),
          reinterpret_cast<char*>(&other->type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ForkInput::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_WorkerRpcInterface_2eproto_getter, &descriptor_table_WorkerRpcInterface_2eproto_once,
      file_level_metadata_WorkerRpcInterface_2eproto[1]);
}

// ===================================================================

class ForkEcho::_Internal {
 public:
  static const ::UserServiceDescriptor& sd(const ForkEcho* msg);
};

const ::UserServiceDescriptor&
ForkEcho::_Internal::sd(const ForkEcho* msg) {
  return *msg->sd_;
}
ForkEcho::ForkEcho(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:ForkEcho)
}
ForkEcho::ForkEcho(const ForkEcho& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  error_text_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    error_text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_error_text().empty()) {
    error_text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_error_text(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_sd()) {
    sd_ = new ::UserServiceDescriptor(*from.sd_);
  } else {
    sd_ = nullptr;
  }
  fail_ = from.fail_;
  // @@protoc_insertion_point(copy_constructor:ForkEcho)
}

inline void ForkEcho::SharedCtor() {
error_text_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  error_text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sd_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&fail_) -
    reinterpret_cast<char*>(&sd_)) + sizeof(fail_));
}

ForkEcho::~ForkEcho() {
  // @@protoc_insertion_point(destructor:ForkEcho)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ForkEcho::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  error_text_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete sd_;
}

void ForkEcho::ArenaDtor(void* object) {
  ForkEcho* _this = reinterpret_cast< ForkEcho* >(object);
  (void)_this;
}
void ForkEcho::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ForkEcho::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ForkEcho::Clear() {
// @@protoc_insertion_point(message_clear_start:ForkEcho)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  error_text_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && sd_ != nullptr) {
    delete sd_;
  }
  sd_ = nullptr;
  fail_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ForkEcho::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .UserServiceDescriptor sd = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_sd(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool fail = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          fail_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string error_text = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_error_text();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "ForkEcho.error_text"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ForkEcho::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ForkEcho)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .UserServiceDescriptor sd = 1;
  if (this->_internal_has_sd()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::sd(this), target, stream);
  }

  // bool fail = 2;
  if (this->_internal_fail() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_fail(), target);
  }

  // string error_text = 3;
  if (!this->_internal_error_text().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_error_text().data(), static_cast<int>(this->_internal_error_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "ForkEcho.error_text");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_error_text(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ForkEcho)
  return target;
}

size_t ForkEcho::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ForkEcho)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string error_text = 3;
  if (!this->_internal_error_text().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_error_text());
  }

  // .UserServiceDescriptor sd = 1;
  if (this->_internal_has_sd()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *sd_);
  }

  // bool fail = 2;
  if (this->_internal_fail() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ForkEcho::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ForkEcho::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ForkEcho::GetClassData() const { return &_class_data_; }

void ForkEcho::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ForkEcho *>(to)->MergeFrom(
      static_cast<const ForkEcho &>(from));
}


void ForkEcho::MergeFrom(const ForkEcho& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ForkEcho)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_error_text().empty()) {
    _internal_set_error_text(from._internal_error_text());
  }
  if (from._internal_has_sd()) {
    _internal_mutable_sd()->::UserServiceDescriptor::MergeFrom(from._internal_sd());
  }
  if (from._internal_fail() != 0) {
    _internal_set_fail(from._internal_fail());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ForkEcho::CopyFrom(const ForkEcho& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ForkEcho)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ForkEcho::IsInitialized() const {
  return true;
}

void ForkEcho::InternalSwap(ForkEcho* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &error_text_, lhs_arena,
      &other->error_text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ForkEcho, fail_)
      + sizeof(ForkEcho::fail_)
      - PROTOBUF_FIELD_OFFSET(ForkEcho, sd_)>(
          reinterpret_cast<char*>(&sd_),
          reinterpret_cast<char*>(&other->sd_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ForkEcho::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_WorkerRpcInterface_2eproto_getter, &descriptor_table_WorkerRpcInterface_2eproto_once,
      file_level_metadata_WorkerRpcInterface_2eproto[2]);
}

// ===================================================================

class ShutdownInput::_Internal {
 public:
  static const ::UserServiceDescriptor& sd(const ShutdownInput* msg);
};

const ::UserServiceDescriptor&
ShutdownInput::_Internal::sd(const ShutdownInput* msg) {
  return *msg->sd_;
}
ShutdownInput::ShutdownInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:ShutdownInput)
}
ShutdownInput::ShutdownInput(const ShutdownInput& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  user_info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_user_info().empty()) {
    user_info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_user_info(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_sd()) {
    sd_ = new ::UserServiceDescriptor(*from.sd_);
  } else {
    sd_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:ShutdownInput)
}

inline void ShutdownInput::SharedCtor() {
user_info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
sd_ = nullptr;
}

ShutdownInput::~ShutdownInput() {
  // @@protoc_insertion_point(destructor:ShutdownInput)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void ShutdownInput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_info_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete sd_;
}

void ShutdownInput::ArenaDtor(void* object) {
  ShutdownInput* _this = reinterpret_cast< ShutdownInput* >(object);
  (void)_this;
}
void ShutdownInput::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void ShutdownInput::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShutdownInput::Clear() {
// @@protoc_insertion_point(message_clear_start:ShutdownInput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  user_info_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && sd_ != nullptr) {
    delete sd_;
  }
  sd_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ShutdownInput::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .UserServiceDescriptor sd = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_sd(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string user_info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_user_info();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "ShutdownInput.user_info"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShutdownInput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ShutdownInput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .UserServiceDescriptor sd = 1;
  if (this->_internal_has_sd()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::sd(this), target, stream);
  }

  // string user_info = 2;
  if (!this->_internal_user_info().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_user_info().data(), static_cast<int>(this->_internal_user_info().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "ShutdownInput.user_info");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_user_info(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ShutdownInput)
  return target;
}

size_t ShutdownInput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ShutdownInput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string user_info = 2;
  if (!this->_internal_user_info().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_info());
  }

  // .UserServiceDescriptor sd = 1;
  if (this->_internal_has_sd()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *sd_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ShutdownInput::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    ShutdownInput::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ShutdownInput::GetClassData() const { return &_class_data_; }

void ShutdownInput::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<ShutdownInput *>(to)->MergeFrom(
      static_cast<const ShutdownInput &>(from));
}


void ShutdownInput::MergeFrom(const ShutdownInput& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:ShutdownInput)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_user_info().empty()) {
    _internal_set_user_info(from._internal_user_info());
  }
  if (from._internal_has_sd()) {
    _internal_mutable_sd()->::UserServiceDescriptor::MergeFrom(from._internal_sd());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ShutdownInput::CopyFrom(const ShutdownInput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ShutdownInput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShutdownInput::IsInitialized() const {
  return true;
}

void ShutdownInput::InternalSwap(ShutdownInput* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &user_info_, lhs_arena,
      &other->user_info_, rhs_arena
  );
  swap(sd_, other->sd_);
}

::PROTOBUF_NAMESPACE_ID::Metadata ShutdownInput::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_WorkerRpcInterface_2eproto_getter, &descriptor_table_WorkerRpcInterface_2eproto_once,
      file_level_metadata_WorkerRpcInterface_2eproto[3]);
}

// ===================================================================

class Echo::_Internal {
 public:
};

Echo::Echo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:Echo)
}
Echo::Echo(const Echo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  error_text_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    error_text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_error_text().empty()) {
    error_text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_error_text(), 
      GetArenaForAllocation());
  }
  fail_ = from.fail_;
  // @@protoc_insertion_point(copy_constructor:Echo)
}

inline void Echo::SharedCtor() {
error_text_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  error_text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
fail_ = false;
}

Echo::~Echo() {
  // @@protoc_insertion_point(destructor:Echo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void Echo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  error_text_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Echo::ArenaDtor(void* object) {
  Echo* _this = reinterpret_cast< Echo* >(object);
  (void)_this;
}
void Echo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Echo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Echo::Clear() {
// @@protoc_insertion_point(message_clear_start:Echo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  error_text_.ClearToEmpty();
  fail_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Echo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool fail = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          fail_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string error_text = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_error_text();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "Echo.error_text"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Echo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Echo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bool fail = 1;
  if (this->_internal_fail() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_fail(), target);
  }

  // string error_text = 2;
  if (!this->_internal_error_text().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_error_text().data(), static_cast<int>(this->_internal_error_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Echo.error_text");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_error_text(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Echo)
  return target;
}

size_t Echo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Echo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string error_text = 2;
  if (!this->_internal_error_text().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_error_text());
  }

  // bool fail = 1;
  if (this->_internal_fail() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Echo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    Echo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Echo::GetClassData() const { return &_class_data_; }

void Echo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<Echo *>(to)->MergeFrom(
      static_cast<const Echo &>(from));
}


void Echo::MergeFrom(const Echo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Echo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_error_text().empty()) {
    _internal_set_error_text(from._internal_error_text());
  }
  if (from._internal_fail() != 0) {
    _internal_set_fail(from._internal_fail());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Echo::CopyFrom(const Echo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Echo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Echo::IsInitialized() const {
  return true;
}

void Echo::InternalSwap(Echo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &error_text_, lhs_arena,
      &other->error_text_, rhs_arena
  );
  swap(fail_, other->fail_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Echo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_WorkerRpcInterface_2eproto_getter, &descriptor_table_WorkerRpcInterface_2eproto_once,
      file_level_metadata_WorkerRpcInterface_2eproto[4]);
}

// ===================================================================

class CheckInput::_Internal {
 public:
};

CheckInput::CheckInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CheckInput)
}
CheckInput::CheckInput(const CheckInput& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  user_info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_user_info().empty()) {
    user_info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_user_info(), 
      GetArenaForAllocation());
  }
  line_ = from.line_;
  // @@protoc_insertion_point(copy_constructor:CheckInput)
}

inline void CheckInput::SharedCtor() {
user_info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
line_ = 0;
}

CheckInput::~CheckInput() {
  // @@protoc_insertion_point(destructor:CheckInput)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CheckInput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  user_info_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CheckInput::ArenaDtor(void* object) {
  CheckInput* _this = reinterpret_cast< CheckInput* >(object);
  (void)_this;
}
void CheckInput::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CheckInput::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CheckInput::Clear() {
// @@protoc_insertion_point(message_clear_start:CheckInput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  user_info_.ClearToEmpty();
  line_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CheckInput::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string user_info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_user_info();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CheckInput.user_info"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 line = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          line_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CheckInput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CheckInput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string user_info = 1;
  if (!this->_internal_user_info().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_user_info().data(), static_cast<int>(this->_internal_user_info().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "CheckInput.user_info");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_user_info(), target);
  }

  // int32 line = 2;
  if (this->_internal_line() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_line(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CheckInput)
  return target;
}

size_t CheckInput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CheckInput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string user_info = 1;
  if (!this->_internal_user_info().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_user_info());
  }

  // int32 line = 2;
  if (this->_internal_line() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_line());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CheckInput::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CheckInput::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CheckInput::GetClassData() const { return &_class_data_; }

void CheckInput::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CheckInput *>(to)->MergeFrom(
      static_cast<const CheckInput &>(from));
}


void CheckInput::MergeFrom(const CheckInput& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CheckInput)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_user_info().empty()) {
    _internal_set_user_info(from._internal_user_info());
  }
  if (from._internal_line() != 0) {
    _internal_set_line(from._internal_line());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CheckInput::CopyFrom(const CheckInput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CheckInput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckInput::IsInitialized() const {
  return true;
}

void CheckInput::InternalSwap(CheckInput* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &user_info_, lhs_arena,
      &other->user_info_, rhs_arena
  );
  swap(line_, other->line_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CheckInput::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_WorkerRpcInterface_2eproto_getter, &descriptor_table_WorkerRpcInterface_2eproto_once,
      file_level_metadata_WorkerRpcInterface_2eproto[5]);
}

// ===================================================================

class DownService::_Internal {
 public:
};

DownService::DownService(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:DownService)
}
DownService::DownService(const DownService& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  error_text_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    error_text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_error_text().empty()) {
    error_text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_error_text(), 
      GetArenaForAllocation());
  }
  alias_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    alias_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_alias().empty()) {
    alias_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_alias(), 
      GetArenaForAllocation());
  }
  out_file_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    out_file_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_out_file().empty()) {
    out_file_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_out_file(), 
      GetArenaForAllocation());
  }
  exit_num_ = from.exit_num_;
  // @@protoc_insertion_point(copy_constructor:DownService)
}

inline void DownService::SharedCtor() {
error_text_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  error_text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
alias_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  alias_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
out_file_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  out_file_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
exit_num_ = 0;
}

DownService::~DownService() {
  // @@protoc_insertion_point(destructor:DownService)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void DownService::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  error_text_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  alias_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  out_file_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void DownService::ArenaDtor(void* object) {
  DownService* _this = reinterpret_cast< DownService* >(object);
  (void)_this;
}
void DownService::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DownService::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DownService::Clear() {
// @@protoc_insertion_point(message_clear_start:DownService)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  error_text_.ClearToEmpty();
  alias_.ClearToEmpty();
  out_file_.ClearToEmpty();
  exit_num_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DownService::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string error_text = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_error_text();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "DownService.error_text"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 exit_num = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          exit_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string alias = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_alias();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "DownService.alias"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string out_file = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_out_file();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "DownService.out_file"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DownService::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DownService)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string error_text = 1;
  if (!this->_internal_error_text().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_error_text().data(), static_cast<int>(this->_internal_error_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "DownService.error_text");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_error_text(), target);
  }

  // int32 exit_num = 2;
  if (this->_internal_exit_num() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_exit_num(), target);
  }

  // string alias = 3;
  if (!this->_internal_alias().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_alias().data(), static_cast<int>(this->_internal_alias().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "DownService.alias");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_alias(), target);
  }

  // string out_file = 4;
  if (!this->_internal_out_file().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_out_file().data(), static_cast<int>(this->_internal_out_file().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "DownService.out_file");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_out_file(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DownService)
  return target;
}

size_t DownService::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DownService)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string error_text = 1;
  if (!this->_internal_error_text().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_error_text());
  }

  // string alias = 3;
  if (!this->_internal_alias().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_alias());
  }

  // string out_file = 4;
  if (!this->_internal_out_file().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_out_file());
  }

  // int32 exit_num = 2;
  if (this->_internal_exit_num() != 0) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_exit_num());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DownService::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DownService::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DownService::GetClassData() const { return &_class_data_; }

void DownService::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DownService *>(to)->MergeFrom(
      static_cast<const DownService &>(from));
}


void DownService::MergeFrom(const DownService& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DownService)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_error_text().empty()) {
    _internal_set_error_text(from._internal_error_text());
  }
  if (!from._internal_alias().empty()) {
    _internal_set_alias(from._internal_alias());
  }
  if (!from._internal_out_file().empty()) {
    _internal_set_out_file(from._internal_out_file());
  }
  if (from._internal_exit_num() != 0) {
    _internal_set_exit_num(from._internal_exit_num());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DownService::CopyFrom(const DownService& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DownService)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DownService::IsInitialized() const {
  return true;
}

void DownService::InternalSwap(DownService* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &error_text_, lhs_arena,
      &other->error_text_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &alias_, lhs_arena,
      &other->alias_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &out_file_, lhs_arena,
      &other->out_file_, rhs_arena
  );
  swap(exit_num_, other->exit_num_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DownService::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_WorkerRpcInterface_2eproto_getter, &descriptor_table_WorkerRpcInterface_2eproto_once,
      file_level_metadata_WorkerRpcInterface_2eproto[6]);
}

// ===================================================================

class DownServices::_Internal {
 public:
};

DownServices::DownServices(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  service_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:DownServices)
}
DownServices::DownServices(const DownServices& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      service_(from.service_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:DownServices)
}

inline void DownServices::SharedCtor() {
}

DownServices::~DownServices() {
  // @@protoc_insertion_point(destructor:DownServices)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void DownServices::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DownServices::ArenaDtor(void* object) {
  DownServices* _this = reinterpret_cast< DownServices* >(object);
  (void)_this;
}
void DownServices::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void DownServices::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DownServices::Clear() {
// @@protoc_insertion_point(message_clear_start:DownServices)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  service_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DownServices::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .DownService service = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_service(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DownServices::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:DownServices)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .DownService service = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_service_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_service(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:DownServices)
  return target;
}

size_t DownServices::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:DownServices)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .DownService service = 1;
  total_size += 1UL * this->_internal_service_size();
  for (const auto& msg : this->service_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DownServices::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    DownServices::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DownServices::GetClassData() const { return &_class_data_; }

void DownServices::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<DownServices *>(to)->MergeFrom(
      static_cast<const DownServices &>(from));
}


void DownServices::MergeFrom(const DownServices& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:DownServices)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  service_.MergeFrom(from.service_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DownServices::CopyFrom(const DownServices& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:DownServices)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DownServices::IsInitialized() const {
  return true;
}

void DownServices::InternalSwap(DownServices* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  service_.InternalSwap(&other->service_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DownServices::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_WorkerRpcInterface_2eproto_getter, &descriptor_table_WorkerRpcInterface_2eproto_once,
      file_level_metadata_WorkerRpcInterface_2eproto[7]);
}

// ===================================================================

class PushInput::_Internal {
 public:
};

PushInput::PushInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:PushInput)
}
PushInput::PushInput(const PushInput& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  service_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    service_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_service().empty()) {
    service_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_service(), 
      GetArenaForAllocation());
  }
  bin_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    bin_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_bin().empty()) {
    bin_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_bin(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:PushInput)
}

inline void PushInput::SharedCtor() {
service_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  service_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
bin_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  bin_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

PushInput::~PushInput() {
  // @@protoc_insertion_point(destructor:PushInput)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void PushInput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  service_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  bin_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void PushInput::ArenaDtor(void* object) {
  PushInput* _this = reinterpret_cast< PushInput* >(object);
  (void)_this;
}
void PushInput::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void PushInput::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PushInput::Clear() {
// @@protoc_insertion_point(message_clear_start:PushInput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  service_.ClearToEmpty();
  bin_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PushInput::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string service = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_service();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "PushInput.service"));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes bin = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_bin();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PushInput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:PushInput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string service = 1;
  if (!this->_internal_service().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_service().data(), static_cast<int>(this->_internal_service().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "PushInput.service");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_service(), target);
  }

  // bytes bin = 2;
  if (!this->_internal_bin().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_bin(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:PushInput)
  return target;
}

size_t PushInput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:PushInput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string service = 1;
  if (!this->_internal_service().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_service());
  }

  // bytes bin = 2;
  if (!this->_internal_bin().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_bin());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PushInput::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    PushInput::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PushInput::GetClassData() const { return &_class_data_; }

void PushInput::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<PushInput *>(to)->MergeFrom(
      static_cast<const PushInput &>(from));
}


void PushInput::MergeFrom(const PushInput& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:PushInput)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_service().empty()) {
    _internal_set_service(from._internal_service());
  }
  if (!from._internal_bin().empty()) {
    _internal_set_bin(from._internal_bin());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PushInput::CopyFrom(const PushInput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:PushInput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushInput::IsInitialized() const {
  return true;
}

void PushInput::InternalSwap(PushInput* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &service_, lhs_arena,
      &other->service_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &bin_, lhs_arena,
      &other->bin_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata PushInput::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_WorkerRpcInterface_2eproto_getter, &descriptor_table_WorkerRpcInterface_2eproto_once,
      file_level_metadata_WorkerRpcInterface_2eproto[8]);
}

// ===================================================================

WorkerService::~WorkerService() {}

const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* WorkerService::descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_WorkerRpcInterface_2eproto);
  return file_level_service_descriptors_WorkerRpcInterface_2eproto[0];
}

const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* WorkerService::GetDescriptor() {
  return descriptor();
}

void WorkerService::fork(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::ForkInput*,
                         ::ForkEcho*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method fork() not implemented.");
  done->Run();
}

void WorkerService::shutdown(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::ShutdownInput*,
                         ::Echo*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method shutdown() not implemented.");
  done->Run();
}

void WorkerService::check(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CheckInput*,
                         ::DownServices*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method check() not implemented.");
  done->Run();
}

void WorkerService::push(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::PushInput*,
                         ::Echo*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method push() not implemented.");
  done->Run();
}

void WorkerService::CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                             ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                             const ::PROTOBUF_NAMESPACE_ID::Message* request,
                             ::PROTOBUF_NAMESPACE_ID::Message* response,
                             ::google::protobuf::Closure* done) {
  GOOGLE_DCHECK_EQ(method->service(), file_level_service_descriptors_WorkerRpcInterface_2eproto[0]);
  switch(method->index()) {
    case 0:
      fork(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::ForkInput*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::ForkEcho*>(
                 response),
             done);
      break;
    case 1:
      shutdown(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::ShutdownInput*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::Echo*>(
                 response),
             done);
      break;
    case 2:
      check(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CheckInput*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::DownServices*>(
                 response),
             done);
      break;
    case 3:
      push(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::PushInput*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::Echo*>(
                 response),
             done);
      break;
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      break;
  }
}

const ::PROTOBUF_NAMESPACE_ID::Message& WorkerService::GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::ForkInput::default_instance();
    case 1:
      return ::ShutdownInput::default_instance();
    case 2:
      return ::CheckInput::default_instance();
    case 3:
      return ::PushInput::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::PROTOBUF_NAMESPACE_ID::MessageFactory::generated_factory()
          ->GetPrototype(method->input_type());
  }
}

const ::PROTOBUF_NAMESPACE_ID::Message& WorkerService::GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::ForkEcho::default_instance();
    case 1:
      return ::Echo::default_instance();
    case 2:
      return ::DownServices::default_instance();
    case 3:
      return ::Echo::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::PROTOBUF_NAMESPACE_ID::MessageFactory::generated_factory()
          ->GetPrototype(method->output_type());
  }
}

WorkerService_Stub::WorkerService_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel)
  : channel_(channel), owns_channel_(false) {}
WorkerService_Stub::WorkerService_Stub(
    ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
    ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership)
  : channel_(channel),
    owns_channel_(ownership == ::PROTOBUF_NAMESPACE_ID::Service::STUB_OWNS_CHANNEL) {}
WorkerService_Stub::~WorkerService_Stub() {
  if (owns_channel_) delete channel_;
}

void WorkerService_Stub::fork(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::ForkInput* request,
                              ::ForkEcho* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(0),
                       controller, request, response, done);
}
void WorkerService_Stub::shutdown(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::ShutdownInput* request,
                              ::Echo* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(1),
                       controller, request, response, done);
}
void WorkerService_Stub::check(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CheckInput* request,
                              ::DownServices* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(2),
                       controller, request, response, done);
}
void WorkerService_Stub::push(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::PushInput* request,
                              ::Echo* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(3),
                       controller, request, response, done);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::UserServiceDescriptor* Arena::CreateMaybeMessage< ::UserServiceDescriptor >(Arena* arena) {
  return Arena::CreateMessageInternal< ::UserServiceDescriptor >(arena);
}
template<> PROTOBUF_NOINLINE ::ForkInput* Arena::CreateMaybeMessage< ::ForkInput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ForkInput >(arena);
}
template<> PROTOBUF_NOINLINE ::ForkEcho* Arena::CreateMaybeMessage< ::ForkEcho >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ForkEcho >(arena);
}
template<> PROTOBUF_NOINLINE ::ShutdownInput* Arena::CreateMaybeMessage< ::ShutdownInput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ShutdownInput >(arena);
}
template<> PROTOBUF_NOINLINE ::Echo* Arena::CreateMaybeMessage< ::Echo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Echo >(arena);
}
template<> PROTOBUF_NOINLINE ::CheckInput* Arena::CreateMaybeMessage< ::CheckInput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CheckInput >(arena);
}
template<> PROTOBUF_NOINLINE ::DownService* Arena::CreateMaybeMessage< ::DownService >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DownService >(arena);
}
template<> PROTOBUF_NOINLINE ::DownServices* Arena::CreateMaybeMessage< ::DownServices >(Arena* arena) {
  return Arena::CreateMessageInternal< ::DownServices >(arena);
}
template<> PROTOBUF_NOINLINE ::PushInput* Arena::CreateMaybeMessage< ::PushInput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::PushInput >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
